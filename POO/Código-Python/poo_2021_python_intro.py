# -*- coding: utf-8 -*-
"""python-intro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TdXeyqJLuNbJewl6EGEvgG1c4Zo4hyEu

# Introdução ao Python da [Data School](http://www.dataschool.io/)

**Related:** [GitHub repository](https://github.com/justmarkham/python-reference)

## Conteúdo

1. Imports
2. Tipos de dados
3. Operações matemáticas
4. Comparações
5. Condicionais
6. Listas
7. Tuplas
8. Strings
9. Dicionários
10. Funções
11. Funções anonimas (Lambda) 
12. Laços
13. Map e Filter

## 1. Imports
"""

# 'import genérico
import math
math.sqrt(25)

# import de uma função
from math import sqrt
sqrt(25)    # não precisa referenciar o módulo

# import de multiplas funções
from math import cos, floor

# import de todas as funções de um módulo
from csv import *

# definindo um alias
import datetime as dt

"""## 2. Tipos de Dados

**Determinando o tipo de um objeto:**
"""

type(2)

type(2.0)

type('two')

type(True)

type(None)

"""**Verifica se um objeto é de um tipo dado:**"""

isinstance(2.0, int)

isinstance(2.0, (int, float))

"""**Conversão:**"""

float(2)

int(2.8)

str(2.9)

"""**Zero, `None`, e empty containers são ditos como `False`:**"""

bool(0)

bool(None)

bool('')    # string vazia

bool([])    # lista vazia

bool({})    # diccionário vazio

"""**Non-empty containers e non-zeros são ditos como `True`:**"""

bool(2)

bool('two')

bool([2])

"""## 3. Operações matemáticas"""

10 + 4

10 - 4

10 * 4

10 ** 4    # expoente

5 % 4      # modulo - calcula o resto

# Python 2: retorna 2 (porque ambos são 'int')
# Python 3: returns 2.5
10 / 4

10 / float(4)

10 // 4    # floor division

"""## 4. Comparações

**Atribuição:**
"""

x = 5

"""**Comparações:**"""

x > 3

x >= 3

x != 3

x == 5

"""**Operações Booleanas:**"""

5 > 3 and 6 > 3

5 > 3 or 5 < 3

not False

False or not False and True     # ordem de avaliação: not, and, or

"""## 5. Condicionais"""

x = -5

# if statement
if x > 0:
    print('positivo')
print('teste')

# if/else statement
if x > 0:
    print('positivo')
else:
    print('zero or negative')

# if/elif/else statement
x = 0
if x > 0:
    print('positive')
elif x == 0:
    print('zero')
else:
    print('negative')

# linha única if statement 
if x > 0: print('positive')

# linha única if/else statement, conhecida como 'operador ternário'
'positive' if x > 0 else 'zero or negative'

x=1

"""## 6. Listas

- **Propriedades:** ordenada, iterable, pode conter tipos diferentes
"""

# cria lista vazia (2 formas)
empty_list = []
empty_list = list()

# cria uma lista
simpsons = ['homer', 'marge', 'bart']

"""**Examina uma lista:**"""

# imprime elemento 0
simpsons[0]

len(simpsons)

"""**Modifica a lista:**"""

# adiciona elemento no final
simpsons.append('lisa')
simpsons

# adiciona multiplos elementos no final
simpsons.extend(['itchy', 'scratchy'])
simpsons

# insere elemento no indice 0 (move todos para direita)
simpsons.insert(0, 'maggie')
simpsons

# procura primeira ocorrencia e remove
simpsons.remove('bart')
simpsons

# remove elemento 0 e retorna
simpsons.pop(0)

simpsons

# remove elemento 0 e não retorna
del simpsons[0]
simpsons

# substitui elemento 0
simpsons[0] = 'krusty'
simpsons

# concatena listas
neighbors = simpsons + ['ned', 'rod', 'todd']
neighbors

"""**Encontra elementos na lista:**"""

# conta número de ocorrecias
simpsons.count('lisa')

# retorna indice a primeira ocorrencia
simpsons.index('itchy')

"""**Quebrando uma Lista:**"""

weekdays = ['mon', 'tues', 'wed', 'thurs', 'fri']

# elemento 0
weekdays[0]

# elementos 0 (inclusive) até 3 (exclusive)
weekdays[0:3]

# inicio implicito em 0
weekdays[:3]

# elementos 3 (inclusive) até o final
weekdays[3:]

weekdays

weekdays[1:3]

# último elemento
weekdays[-1]

# todo 2o elemento (passo 2)
weekdays[::2]

# reverso (passo -1)
weekdays[::-1]

# método alternativo
list(reversed(weekdays))

"""**Ordena uma lista (modifica mas não retorna):**"""

simpsons.sort()
simpsons

simpsons

# ordena inversamente
simpsons.sort(reverse=True)
simpsons

# ordena por uma chave
simpsons.sort(key=len)
simpsons

"""**Retorna uma lista ordenada (não modifica a lista original):**"""

sorted(simpsons)

simpsons

sorted(simpsons, reverse=True)

sorted(simpsons, key=len)

"""**Insere em uma lista já ordenada e mantem a ordem:**"""

num = [10, 20, 40, 50]
from bisect import insort
insort(num, 30)
num

"""**Referencias e cópias:**"""

# cria uma segunda referencia para a mesma lista
same_num = num

num

# modifica ambas as listas 'num' e 'same_num'
same_num[0] = 0
print(num)
print(same_num)

# copia uma lista (2 formas)
new_num = num[:]
new_num = list(num)

new_num[0] = 0

same_num

new_num

"""**Checa objetos:**"""

num is same_num    # checa se são o mesmo objeto

same_num is new_num

num == same_num    # checa se possuem o mesmo conteúdo

num == new_num

"""## 7. Tuplas

- **Propriedades:** ordena, itera, não muda, pode conter multiplos tipos
- Como as listas, mas não mudam tamanho
"""

# cria diretamente
digits = (10, 25, 'two')

# cria a partir de uma lista
digits = tuple([0, 1, 'two'])

"""**Checa uma tupla:**"""

digits[2]

len(digits)

# conta o numero de ocorrências com o valor
digits.count(25)

# rretorna o indice da primeira ocorrencia
digits.index(25)

"""**Modificar uma tupla:**"""

# elementos de uma tupla não podem ser modificados
# digits[2] = 30

# concatena tuplas
digits = digits + (3, 4)
digits

"""**Outras operações:**"""

# cria uma tupla com elementos repetidos
(3, 40) * 10

# ordena uma lista de tuplas
tens = [(20, 60), (10, 40), (20, 30)]
sorted(tens)    # sorts by first element in tuple, then second element

bart = ('male', 10, 'simpson')    # cria uma tupla
(sex, age, surname) = bart        # 3 atribuições combinadas
print(sex)
print(age)
print(surname)

"""## 8. Strings"""

# conversão
s = str(42)
s

# cria diretamente
s = 'I like you'

"""**Checa uma string:**"""

s[0]

len(s)

"""**Quebrando String:**"""

s[:6]

s[7:]

s[-1]

"""**Operações básicas:**"""

s.lower()

s.upper()

s.startswith('I')

s.endswith('you')

# checa se os caracteres são digitos
s.isdigit()

# retorna indice da ocorrencia
s.find('like')

s

# retorna -1 quando não encontra
s.find('hate')

# substitui todas as ocorrencias de 'like' por 'love'
s.replace('like', 'love')

"""**Dividindo uma string:**"""

# Dividir uma string em uma lista com separador
s.split(' ')

# equivalente pois espaço é o padrão
s.split()

s2 = 'a :  an : the'
s2.split(':')

# concatena
s3 = 'The meaning of life is'
s4 = '42'
s3 + ' ' + s4

"""**Remove espaços do inicio e fim:**"""

s5 = '  ham and cheese  '
s5.strip()

# substituições
'raining {} and {}'.format('cats', 'dogs')

# substituições 2
'raining {arg2} and {arg1}'.format(arg1='cats', arg2='dogs')

# formatação decimal
'pi is {:.2f}'.format(3.14159)

"""## 9. Dicionários

- **Propriedades:** não ordenado, itera, muda, pode contar multiplos tipos
- Feito de pares key-value
- Chaves devem ser únicas e podem ser strings, numeros ou tuplas
"""

# dic. vazio
empty_dict = {}
empty_dict = dict()

# 2 formas de criar um dic.
family = {'dad':'homer', 'mom':'marge', 'size':6}
family = dict(dad='homer', mom='marge', size=6)
family

# converte uma lista de tuplas em um dic.
list_of_tuples = [('dad', 'homer'), ('mom', 'marge'), ('size', 6)]
family = dict(list_of_tuples)
family

"""**Checa um dic.:**"""

# passa a chave e retorna o valor
family['size']

# retorna o número de pares key-value
len(family)

# checa se uma chave existe
'mom' in family

# valores não são checados
'marge' in family

# retorna uma view iterable
family.values()

# retorna uma view iterable
family.items()

"""**Modificações:**"""

# nova entrada
family['cat'] = 'snowball'
family

# editando um item
family['cat'] = 'snowball ii'
family

# deletando um item
del family['cat']
family

# valores podem ser listas
family['kids'] = ['bart', 'lisa']
family

family['kids'][0]

# remove um item e retorna seu valor
family.pop('dad')

family

# adiciona entradas multiplas
family.update({'baby':'maggie', 'grandpa':'abe'})
family

"""**Acessando valores de forma mais segura com `get`:**"""

family['mom']

family.get('mom')

# erro mais a chave não existe
# family['grandma']

family.get('grandma')

# especifica um valor padrão para não encontrado
family.get('grandma', 'chave não encontrada!')

"""**Acesso a uma lista em um dic.:**"""

family['kids']

family['kids'].remove('lisa')
family

family['kids']

"""## 10. Funções"""

def print_text():
    print("this is text")

# chama a função
print_text()

def print_this(x):
    print(x)

print_this('Ola turma!')

def square_this(x):
    return x**2

square_this(3)

var = square_this(3)

def calc(a, b, op='add'):
    if op == 'add':
        return a + b
    elif op == 'sub':
        return a - b
    else:
        print('valid operations are add and sub')

calc(10, 4, op='add')

calc(b=1, op='sub', a=5)

calc(10, 4, 'add')

calc(10, 4)

calc(10, 4, 'sub')

calc(10, 4, 'div')

"""**Retorna 2 valores:**"""

def min_max(nums):
    return min(nums), max(nums)

# valores retornados podem ser atribuidos a uma tupla
nums = [1, 2, 3, 4, 5, 6, 7, 8]
min_max_num = min_max(nums)
min_max_num

# valores retornados podem ser atribuidos a multiplas variáveis
min_num, max_num = min_max(nums)
print(min_num)
print(max_num)

"""## 12. Funções anonimas (Lambda)"""

# forma tradicional
def squared(x):
    return x**2

# forma anonima
squared = lambda x: x**2

"""**Ordena uma lista de strings pela última letra:**"""

# forma tradicional
simpsons = ['homer', 'marge', 'bart']

def ultima_letra(word):
    return word[-1]

sorted(simpsons, key=ultima_letra)

t = "Fatec"
print(t[-1])

# forma anonima
sorted(simpsons, key=lambda word: word[-1])

"""## 13. Laços"""

# inclui o valor inicial mas exclui o valor de parada
range(0, 3)

# valor inicial padrão é 0
range(3)

# terceiro argumento é o passo
range(0, 5, 2)

"""**`for`:**"""

fruits = ['apple', 'banana', 'cherry']
for fruit in fruits:
    print(fruit.upper())

fruits[0]

family = {'dad':'homer', 'mom':'marge', 'size':6}
for key, value in family.items():
    print(key, value)

# acessando o valor de indice
for index, fruit in enumerate(fruits):
    print(index, fruit)

"""**`while`:**"""

count = 0
while count < 5:
    print('This will print 5 times')
    count += 1

"""**List comprehension:**"""

nums = [1, 2, 3, 4, 5]
cubes = []
for num in nums:
    cubes.append(num**3)
cubes

# equivalente com list comprehension
cubes = [num**3 for num in nums]
cubes

cubes_and_squares = []
for num in nums:
    if num % 2 == 0:
        cubes_and_squares.append(num**3)
    else:
        cubes_and_squares.append(num**2)
cubes_and_squares

# equivalente list comprehension utilizando expressões ternárias
cubes_and_squares = [num**3 if num % 2 == 0 else num**2 for num in nums]
cubes_and_squares

matrix = [[1, 2], [3, 4]]
items = []
for row in matrix:
    for item in row:
        items.append(item)
items

# equivalente com list comprehension
items = [item for row in matrix
              for item in row]
items

"""**Dictionary comprehension:**"""

fruit_lengths = {fruit:len(fruit) for fruit in fruits}
fruit_lengths

fruit_indices = {fruit:index for index, fruit in enumerate(fruits)}
fruit_indices

"""## 15. Map e Filter

**`map` aplica uma função a cada elemento de uma sequencia e retorna um iterator:**
"""

simpsons = ['homer', 'marge', 'bart']
list(map(len, simpsons))

# equivalente em list comprehension
[len(word) for word in simpsons]

list(map(lambda word: word[-1], simpsons))

# equivalente em list comprehension
[word[-1] for word in simpsons]

"""**`filter` retorna um iterator contendo os elementos de uma sequencia da qual a condição é `True`:**"""

nums = range(5)
list(nums)

list(filter(lambda x: x % 2 == 0, nums))

# equivalent em list comprehension
[num for num in nums if num % 2 == 0]